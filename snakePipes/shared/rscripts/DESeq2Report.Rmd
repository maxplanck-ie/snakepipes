---
output:
  BiocStyle::html_document:
    toc: true
    toc_float: true
    code_folding: hide
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
    theme: spacelab
  pdf_document:
      toc: true
  knitrBootstrap::bootstrap_document:
    theme.chooser: TRUE
    highlight.chooser: TRUE
params:
    DEseqoutRdata: 'test'
    ddr.df: 'test'
    countdata: 'test'
    coldata: 'test'
    fdr: 0.05
    heatmap_topN: 20
    geneNamesFile: 'test'
---

```{r setup}
#### Libraries needed
.libPaths(R.home('library'))

## Bioconductor
suppressPackageStartupMessages(library('DESeq2'))

## CRAN
suppressPackageStartupMessages(library('ggplot2'))
suppressPackageStartupMessages(library('knitr'))
suppressPackageStartupMessages(library('RColorBrewer'))
suppressPackageStartupMessages(library('pheatmap'))
suppressPackageStartupMessages(library('DT'))

## Preset variables
software = 'DESeq2'
device = "png"
outputIsHTML = TRUE
isEdgeR = FALSE
nBest = 200
theme = theme_bw()
searchURL = "http://www.ncbi.nlm.nih.gov/gene/?term="
digits = 2
nBestFeatures = 10
tmpdir <- getwd()
theCall = NULL
startTime <- Sys.time()
intgroup <- c("name", "condition")
```

snakePipes : `r software` results exploration
==============================================

# Introduction

This report is meant to help explore `r software` `r citep(bib[['DESeq2']])` results and was generated using Rmarkdown. While the report is rich, it is meant to just start the exploration of the results and exemplify some of the code used to do so. If you need a more in-depth analysis for your specific data set you might want to use the Rdata objects generated in the DESeq2 output folder. This report is based on the vignette of the `DESeq2` `r citep(bib[['DESeq2']])` package which you can find [here](http://www.bioconductor.org/packages/DESeq2).

## Code setup

This section contains the code for setting up the rest of the report.

```{r docSetup, echo = FALSE, bootstrap.show.code = FALSE, dev = device, bootstrap.show.message=FALSE}
## knitrBoostrap and device chunk options
library('knitr')
opts_chunk$set(bootstrap.show.code = FALSE, dev = device)
if(!outputIsHTML) opts_chunk$set(bootstrap.show.code = FALSE, dev = device, echo = FALSE)
```

```{r setup2, bootstrap.show.message=FALSE}
#### Code setup
## res (ddr) and dds are transferred to the template via DESeq2report function
## I also need to transfer countdata, coldata and
load(params$DEseqoutRdata) ## dds and ddr

ddr.df <- params$ddr.df  #_DEresults.tsv file
countdata <- params$countdata
coldata <- params$coldata
fdr <- params$fdr
heatmap_topN <- params$heatmap_topN
geneNamesFile <- params$geneNamesFile

## For ggplot
res <- ddr
ddr.df <- read.delim(ddr.df)
res.df <- ddr.df

## Sort results by adjusted p-values
ord <- order(res.df$padj, decreasing = FALSE)
res.df <- res.df[ord, ]
features <- rownames(res.df)
res.df <- cbind(data.frame(Feature = features), res.df)
rownames(res.df) <- NULL
```

## Preparing outputs for exploration

Most of the exploration below is based on the annotated DESeq2 output file generated by snakePipes after running DESeq2.

```{r ddsprocess, echo=FALSE}
    df.filt <- ddr.df[which(ddr.df$padj < fdr),]
    df.plot <- data.frame(Status = c("Up","Down"),
                    Genes = c(sum(df.filt$Status == "UP"),
                            sum(df.filt$Status == "DOWN"))
    )
    message("Filtered data set")
    print(head(df.filt))

    ## Rlog transform
    rld <- DESeq2::rlog(dds)

    ## Expression density data (add mean and independent filtering threshold)
    #print("Preparing data: expression density")
    toplot <- data.frame(DESeq2::counts(dds, normalized = T))
    toplot <- stack(toplot, select = colnames(toplot))
    ind_filt_thres <- as.numeric(S4Vectors::metadata(ddr)$filterThreshold)
    # plotdata
    pld <- ggplot(toplot, aes(values, colour = ind, alpha = 0.5)) +
        geom_line(aes(color = ind), stat = "density", alpha = 0.5) +
        scale_x_log10(name = "\nnormalized counts",
                  breaks = c(0.1,1,10,100,1000,10000,100000),
                  limits = c(0.1,100000) ) +
        scale_y_continuous(name = "density\n") +
        scale_colour_discrete(name = "Samples") +
        geom_vline(xintercept = 10, colour = "grey", linetype = "dashed") +
        #theme_minimal() +
        ggtitle("Density plot\n")

    ## Sample distances
    #print("Preparing data: sample distances")
    sampleDists <- dist(t(SummarizedExperiment::assay(rld)))

    ## Euclidean sample distance heatmap
    sampleDistMatrix <- as.matrix(sampleDists)
    rownames(sampleDistMatrix) <- sprintf("%s\n(%s)", colnames(rld), rld$condition)
    colnames(sampleDistMatrix) <- sprintf("%s\n(%s)", colnames(rld), rld$condition)
    colours <- colorRampPalette(rev(RColorBrewer::brewer.pal(9, "GnBu")))(255)

    ## PCA data
    #print("Preparing data: PCA")
    PCAdata <- DESeq2::plotPCA(rld, intgroup = intgroup, returnData=TRUE)
    percentVar <- round(100 * attr(PCAdata, "percentVar"))


    ## Take out cooks distance statistics for outlier detection
    W <- ddr$stat
    maxCooks <- apply(SummarizedExperiment::assays(dds)[["cooks"]],1,max)
    idx <- !is.na(W)
    m <- ncol(dds)
    p <- 3

    ## Extract data for heatmap
    # order by fold change (by abs foldch if only few top genes requested)
    #print("Preparing data: heatmap")
    if (nrow(df.filt) > 0) {
        d <- data.frame(id = rownames(df.filt), padj = df.filt$padj)
        if (length(rownames(d)) < heatmap_topN ) {
            heatmap_topN <- nrow(d)
        }

        d_topx_padj <- d[order(d$padj, decreasing = F),][1:heatmap_topN,]
        heatmap_data <- SummarizedExperiment::assay(rld)[as.character(d_topx_padj$id),]
        ## create another df to get the gene names
        if (file.exists(geneNamesFile) && "external_gene_name" %in% colnames(ddr.df)) {
            mdf <- data.frame(row.names = rownames(ddr.df), external_gene_name = ddr.df$external_gene_name)
            htdat <- merge(mdf, heatmap_data, by = 0, all.y = TRUE, order = FALSE)
            napos <- which(is.na(htdat$external_gene_name))
            htdat[napos, "external_gene_name"] <- as.character(htdat[napos, "Row.names"])

            # replace rownames of heatmap data with these gene names
            rownames(heatmap_data) <- htdat$external_gene_name[match(rownames(heatmap_data),htdat$Row.names)]
        }
        ## scaling is not so useful for already normalized data, or?
        #heatmap_data <- scale(heatmap_data, center = TRUE, scale = TRUE)
    } else {
        if(nrow(df.filt) == 0){ message("No DE genes detected!") }
    }
```

# Sparsity of counts

```{r 'sparsity'}
# 1. sparsity
DESeq2::plotSparsity(dds)
```

A simple plot of the concentration of counts in a single sample over the sum of counts per gene. This plot is useful diagnostic for datasets which might not fit a negative binomial assumption: genes with many zeros and individual very large counts are difficult to model with the negative binomial distribution.

# Density of counts

```{r density, warning=FALSE, message=FALSE}
    # 2. expression density plot (add mean and independent filtering threshold)
    pld + geom_line(data = ddr.df, aes(baseMean),
                stat = "density", alpha = 0.5, colour = "blue", size = 1.1) +
        geom_vline(xintercept = ind_filt_thres, colour = "red", size=1.1) +
        ggtitle(sprintf("Density plot\n(independent filtering: %.3f)\n", ind_filt_thres)) +
        theme(legend.position = "bottom")
```

This plot shows the density distribution of normalized counts per sample. DE estimates for genes with very low counts are unreliable. The **red line** shows the independent filtering cutoff used by DESeq2 to remove too low counts from the data during testing of DE.

# Sample-to-sample distances

```{r sampledist}
# 4. Sample distances heatmap
pheatmap(sampleDistMatrix, color = colours, display_numbers = TRUE)
```

This plot shows how samples are clustered based on their euclidean distance using the regularized log transformed count data. This figure gives an overview of how the samples are hierarchically clustered. It is a complementary figure to the PCA plot.

# PCA

```{r PCA, eval = TRUE}
    # 5. PCA plots
    PCAdata$name<-make.names(PCAdata$name,unique=TRUE)
    print(ggplot(PCAdata, aes(PC1, PC2, color = condition, shape = name)) +
        geom_hline(aes(yintercept = 0), colour = "grey") +
        geom_vline(aes(xintercept = 0), colour = "grey") +
        geom_point(size = 5) +
        xlab(paste0("PC1: ", percentVar[1], "% variance")) +
        ylab(paste0("PC2: ", percentVar[2], "% variance")) +
        #theme_bw(base_size = 14) +
        ggtitle("PCA\n") +
        scale_shape_manual(values = c(0:18,33:17))
    )
```


The above plot shows the first two principal components that explain the variability in the data using the regularized log count data. If you are unfamiliar with principal component analysis, you might want to check the [Wikipedia entry](https://en.wikipedia.org/wiki/Principal_component_analysis) or this [interactive explanation](http://setosa.io/ev/principal-component-analysis/). In this case, the first and second principal component explain `r percentVar[1]` and `r percentVar[2]` percent of the variance respectively.

# Cook's Distance

```{r cooks}
    # 6. Cooks distance
    plot(rank(W[idx]), maxCooks[idx], xlab = "rank of Wald statistic",
         ylab = "maximum Cook's distance per gene",
         ylim = c(0,5), cex = .4, col = rgb(0,0,0,.3))
    abline(h = qf(.99, p, m - p))
```

This plot shows the [cooks distance](https://en.wikipedia.org/wiki/Cook%27s_distance) for all genes in the data, which is used by DESeq2 for detection of outliers. Samples with high cook's distance (DESeq2 uses a cutoff of **6**), are automatically removed from analysis, provided enough replicates are available.

# Dispersion fitting

```{r dispersion}
    # 3. Dispersion estimates
    DESeq2::plotDispEsts(dds)
```

This plot shows the fitting of [dispersion](https://en.wikipedia.org/wiki/Statistical_dispersion) estimates for all genes by DESeq2. A better fit would mean more reliable results.

# MA plots

The formula used to model gene expression in this analysis is `r paste(design(dds),collapse="")`.

This section contains three MA plots (see [Wikipedia](https://en.wikipedia.org/wiki/MA_plot)) that compare the mean of the normalized counts against the log fold change. They show one point per feature. The points are shown in red if the feature has an adjusted p-value less than `alpha`, that is, the statistically significant features are shown in red.

```{r 'MAplotalpha'}
## MA plot with alpha used in DESeq2::results()
plotMA(res, alpha = metadata(res)$alpha, main = paste('MA plot with alpha =',
    metadata(res)$alpha))
```

This first plot shows uses `alpha` = `r metadata(res)$alpha`, which is the `alpha` value used to determine which resulting features were significant when running the function `DESeq2::results()`.


```{r 'MAplotalphaHalf'}
## MA plot with alpha = 1/5 of the alpha used in DESeq2::results()
plotMA(res, alpha = metadata(res)$alpha / 5,
    main = paste('MA plot with alpha =', metadata(res)$alpha / 2))
```

This second MA plot uses `alpha` = `r metadata(res)$alpha / 2` and can be used agains the first MA plot to identify which features have adjusted p-values between `r metadata(res)$alpha / 2` and `r metadata(res)$alpha`.

```{r 'MAplotalpha-nBest'}
## MA plot with alpha corresponding to the one that gives the nBest features
nBest.actual <- min(nBest, nrow(head(res.df, n = nBest)))
nBest.alpha <- head(res.df, n = nBest)$padj[nBest.actual]
plotMA(res, alpha = nBest.alpha * 1.00000000000001,
    main = paste('MA plot for top', nBest.actual, 'features'))
```

The third and final MA plot uses an alpha such that the top `r nBest.actual` features are shown in the plot. These are the features that whose details are included in the _top features_ interactive table.


#  Volcano plot

```{r volcano, eval = TRUE, warning=FALSE}

    # 9. Volcano plot
    volcano_xlim <- max(abs(quantile(na.omit(ddr.df$log2FoldChange),p= c(0.01, 0.99)) ) )
    volcano_ylim <- quantile(-log(na.omit(ddr.df$padj) ), p = 0.99)
    print(ggplot(ddr.df, aes(log2FoldChange, -log10(padj))) +
        geom_point(alpha = 0.4, size = 1, colour = "grey50") +
        scale_x_continuous(limits = c(-volcano_xlim, volcano_xlim)) +
        scale_y_continuous(limits = c(0, volcano_ylim) ) +
        geom_vline(xintercept = 0, col = "navy") +
        geom_point(data = df.filt, aes(log2FoldChange, -log10(padj)), alpha = 0.6, size = 1, colour = "red" ) +
        theme_bw(base_size = 14) +
        labs(x = "log2-fold change",
             y = "-log10 (padj)",
             title = sprintf("Volcano plot\n(FDR: %.2f, up: %d, down: %d)",
                         fdr, df.plot$Genes[df.plot$Status == 'Up'],
                         df.plot$Genes[df.plot$Status == 'Down']))
    )
```

[Volcano plots](https://en.wikipedia.org/wiki/Volcano_plot_(statistics)) are another (sometimes preferred) way of visulizing the DE results. It clearly identifies the highest changing genes from the results.


# Bar plot

```{r bar, eval=TRUE}
    # 10. UP/DOWN barplot
    print(ggplot(df.plot,ggplot2::aes(Status, Genes, fill = Status)) +
             geom_bar(stat = "identity", position = "dodge")
    )
```

The good old bar plot of UP and DOWN regulated genes.

# P-values distribution

```{r pvalue, eval=TRUE, message=FALSE, warning=FALSE}

    # 9. P-value distribution
    print(ggplot(ddr.df) +
        geom_histogram(aes(pvalue, fill = "a"), colour = "grey20", alpha = 0.5, stat = "bin") +
        geom_histogram(aes(padj, fill = "b"), colour = "grey20", alpha = 0.5, stat = "bin") +
        scale_fill_manual(name = "group", values = c("a" = "steelblue", "b" = "grey20"),
                    labels = c("a" = "p-value", "b" = "padj")) +
        geom_vline(xintercept = fdr, colour = "red")
    )
```

This plot shows a histogram of the unadjusted and adjusted p-values.

**Unadjusted P-values (grey)** might be skewed right or left, or flat as shown in the [Wikipedia examples](https://en.wikipedia.org/wiki/Histogram#Examples). The shape depends on the percent of features that are differentially expressed. For further information on how to interpret a histogram of p-values check [David Robinson's post on this topic](http://varianceexplained.org/statistics/interpreting-pvalue-histogram/).

**Blue bars** show the distribution of the `r elementMetadata(res)$description[grep('adjusted', elementMetadata(res)$description)]`. It might be skewed right or left, or flat as shown in the [Wikipedia examples](https://en.wikipedia.org/wiki/Histogram#Examples).

Below is the numerical summary of the distribution of the p-values.

```{r pvalueSumm}
## P-value distribution summary
summary(res.df$pvalue)
```

This is the numerical summary of the distribution of the `r elementMetadata(res)$description[grep('adjusted', elementMetadata(res)$description)]`.

```{r padjSumm}
## Adjusted p-values distribution summary
summary(res.df$padj)
```

The table below shows the number of features with `r elementMetadata(res)$description[grep('adjusted', elementMetadata(res)$description)]` less or equal than some commonly used cutoff values.

```{r padjTable, results = 'asis'}
## Split features by different adjusted p-value cutoffs
padj_table <- lapply(c(1e-04, 0.001, 0.01, 0.025, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5,
    0.6, 0.7, 0.8, 0.9, 1), function(x) {
    data.frame('Cut' = x, 'Count' = sum(res.df$padj <= x, na.rm = TRUE))
})
padj_table <- do.call(rbind, padj_table)
if(outputIsHTML) {
    kable(padj_table, format = 'markdown', align = c('c', 'c'))
} else {
    kable(padj_table)
}
```


# Heatmap - normalized counts

```{r 'heatmap', eval = TRUE, fig.show=TRUE}
# 7. Heatmap topN genes rld
if (nrow(df.filt) > 0) {
    pheatmap(heatmap_data,
             cluster_rows = TRUE,
             clustering_method = "average",
             show_rownames = TRUE,
             cluster_cols = FALSE,
             color = colorRampPalette(RColorBrewer::brewer.pal(9,"YlGnBu"))(255),
             main = sprintf("Heatmap : Top %d DE genes (by p-value) color: norm. expression (rld) ", heatmap_topN))
} else {
  message("No DE genes detected")
}
```

This plot shows a heatmap of DESeq2-normlized counts for the **top 20** differentially expressed genes.

# Heatmap - Z-scores

```{r 'heatmap2', fig.show=TRUE}
# 7.1 Heatmap topN genes z-score
if (nrow(df.filt) > 0) {
    pheatmap(heatmap_data,
             cluster_rows = TRUE,
             clustering_method = "average",
             show_rownames = TRUE,
             cluster_cols = FALSE,
             scale = "row",
             color = colorRampPalette(rev(RColorBrewer::brewer.pal(9,"RdBu")))(255),
             main = sprintf("Heatmap : Top %d DE genes (by p-value) color: z-score  ", heatmap_topN))
} else {
  if(nrow(df.filt) == 0){ message("No DE genes detected!") }
}
```

This plot shows the same heatmap as the one above, however instead of actual counts, it shows the rwo-wise z-scores of counts, for the **top 20** differentially expressed genes.


# Top features

This `r ifelse(outputIsHTML, 'interactive', '')` table shows the top `r nBest.actual` features ordered by their `r elementMetadata(res)$description[grep('adjusted', elementMetadata(res)$description)]`. `r ifelse(outputIsHTML, 'Use the search function to find your feature of interest or sort by one of the columns.', 'Since the report is in PDF format, only the top 20 features are shown.')`

```{r 'topFeatures', results = 'asis'}

## Add search url if appropriate
if(!is.null(searchURL) & outputIsHTML) {
    res.df$Feature <- paste0('<a href="', searchURL, res.df$Feature, '">',
        res.df$Feature, '</a>')
}

for(i in which(colnames(res.df) %in% c('pvalue', 'padj'))) res.df[, i] <- format(res.df[, i], scientific = TRUE)

if(outputIsHTML) {
    datatable(head(res.df, n = nBest), options = list(pagingType='full_numbers', pageLength=10, scrollX='100%'), escape = FALSE, rownames = FALSE) %>% formatRound(which(!colnames(res.df) %in% c('pvalue', 'padj', 'Feature','Status','external_gene_name')), digits)
} else {
    res.df_top <- head(res.df, n = 20)
    for(i in which(!colnames(res.df) %in% c('pvalue', 'padj', 'Feature','Status','external_gene_name'))) res.df_top[, i] <- round(res.df_top[, i], digits)
    kable(res.df_top)
}

```




# Count plots top features


This section contains plots showing the normalized counts per sample for each group of interest. Only the best `r nBestFeatures` features are shown, ranked by their `r elementMetadata(res)$description[grep('adjusted', elementMetadata(res)$description)]`. The Y axis is on the log10 scale and the feature name is shown in the title of each plot.


```{r 'plotCounts'}
plotCounts_gg <- function(i, dds, intgroup) {
    group <- if (length(intgroup) == 1) {
        colData(dds)[[intgroup]]
    } else if (length(intgroup) == 2) {
        lvls <- as.vector(t(outer(levels(colData(dds)[[intgroup[1]]]),
            levels(colData(dds)[[intgroup[2]]]), function(x,
                y) paste(x, y, sep = " : "))))
        droplevels(factor(apply(as.data.frame(colData(dds)[,
            intgroup, drop = FALSE]), 1, paste, collapse = " : "),
            levels = lvls))
    } else {
        factor(apply(as.data.frame(colData(dds)[, intgroup, drop = FALSE]),
            1, paste, collapse = " : "))
    }
    data <- plotCounts(dds, gene=i, intgroup=intgroup, returnData = TRUE)
    ## Change in version 1.15.3
    ## It might not be necessary to have any of this if else, but I'm not
    ## sure that plotCounts(returnData) will always return the 'group' variable.
    if('condition' %in% colnames(data)) {
        data$group <- group
    } else {
        data <- cbind(data, data.frame('group' = group))
    }

    ggplot(data, aes(x = group, y = log10(count))) + geom_jitter(width=0.2) + ylab('Log10(Normalized count + 0.5)') + ggtitle(i) + theme(axis.text.x = element_text(angle = 90, hjust = 1))
}
for(i in head(features, nBestFeatures)) {
    print(plotCounts_gg(i, dds = dds, intgroup = intgroup[2:length(intgroup)]))
}
```


# Reproducibility

The input for this report was generated with `r software` `r if(software == 'edgeR') citep(bib[[c('edgeR1', 'edgeR2', 'edgeR6')]]) else if (software == 'DESeq2') citep(bib[['DESeq2']]) else citep(bib[['other']])` `r if(software == 'DESeq2') paste('using version', metadata(dds)$version)` and the resulting features were called significantly differentially expressed if their `r elementMetadata(res)$description[grep('adjusted', elementMetadata(res)$description)]` were less than `alpha` = `r metadata(res)$alpha`. This report was generated in path `r tmpdir`.

Date the report was generated.

```{r reproducibility1, echo=FALSE}
## Date the report was generated
Sys.time()
```

Wallclock time spent generating the report.

```{r reproducibility2, echo=FALSE}
## Processing time in seconds
totalTime <- diff(c(startTime, Sys.time()))
round(totalTime, digits=3)
```

`R` session information.

```{r reproducibility3, echo=FALSE}
## Session info
options(width = 120)
sessionInfo()
```

Pandoc version used: `r rmarkdown::pandoc_version()`.

# Bibliography

This report was created with using `rmarkdown` `r citep(bib[['rmarkdown']])` while `knitr` `r citep(bib[['knitr']])` and  `DT` `r citep(bib[['DT']])` were running behind the scenes. `pheatmap` `r citep(bib[['pheatmap']])` was used to create the sample distances heatmap. Several plots were made with `ggplot2` `r citep(bib[['ggplot2']])`.

Citations made with `knitcitations` `r citep(bib[['knitcitations']])`. The [BibTeX](http://www.bibtex.org/) file can be found [here](`r 'citations.bib'`).

```{r bibliography, results='asis', echo=FALSE, warning = FALSE}
## Print bibliography
bibliography(style="html")
```
